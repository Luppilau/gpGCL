use std::str::FromStr;
use crate::ast::{Expr, ExprOpcode};
use crate::ast::{LogicalExpr, LogicalOpcode, LogicalExprOpcode};
use crate::ast::{Command, Probability};

grammar;

// ----- ARITHMETIC EXPRESSIONS ----- 

pub Expr: Box<Expr> = {
  Expr ExprOp Expr2 => Box::new(Expr::ExprOp(<>)),
  Expr2,
};

Expr2: Box<Expr> = {
  Expr2 Expr2Op Var => Box::new(Expr::ExprOp(<>)),
  Var,
};

Var: Box<Expr> = {
  NumLiteral => Box::new(Expr::Number(<>)),
  Identifier => Box::new(Expr::Variable(<>)),
};

NumLiteral: i32 = {
  r"[0-9]+" => i32::from_str(<>).unwrap(), 
};

Identifier: String = {
  r"[a-zA-Z]+" => <>.to_string(),
};


ExprOp: ExprOpcode = { // (3)
  "+" => ExprOpcode::Add,
};

Expr2Op: ExprOpcode = {
  "*" => ExprOpcode::Mul,
};


// ----- LOGICAL EXPRESSIONS ----- 

pub LogicalExpr: Box<LogicalExpr> = {
  "!" <a:LogicalExpr> => Box::new(LogicalExpr::Not(a)),
  LogicalExpr2
};

LogicalExpr2: Box<LogicalExpr> = {
  LogicalExpr2 LogicalOp LogicalExpr3 => Box::new(LogicalExpr::LogicalOp(<>)),
  LogicalExpr3,
};

LogicalExpr3: Box<LogicalExpr> = {
  Expr LogicalExprOp Expr  => Box::new(LogicalExpr::LogicalExprOp(<>))
};


LogicalOp: LogicalOpcode = {
  "&" => LogicalOpcode::And,
};

LogicalExprOp: LogicalExprOpcode = {
  "<" => LogicalExprOpcode::LessThan,
};

// ----- COMMANDS -----
// skip | x := e | C; C | {C} [p] {C} | if (Ï†) {C} else {C}

pub Command: Box<Command> = {
  <l:Command> ";" <r:Command2> => Box::new(Command::Sequence(<>)),
  Command2,
}

Command2: Box<Command> = {
  "{" <l:Command2> "}" "[" <p:Probability> "]" "{" <r:Command2> "}" => Box::new(Command::ProbabilisticChoice(<>)),
  // Command3,
}

// Command3: Box<Command> = {
//   "if" "(" <c:LogicalExpr> ")" "{" <l:Command2> "}" "else" "{" <r:Command2> "}"
//   Command3,
// }

Probability: f32 = {
  r"[+-]?[0-9]*\.[0-9]+" => Expr::Literal(f32::from_str(<>).unwrap()),
}